#summary Map features in an XML file.
#labels Phase-Design

A tarball containing XML files for several languages (now with more data) is available at http://userpage.fu-berlin.de/hdinh/xml.tar.bz2

= XML schema =

{{{
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://code.google.com/p/swp-dv-ws2010-osm-1/OSM_Tags" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://code.google.com/p/swp-dv-ws2010-osm-1/OSM_Tags">
	<!--  Element: key -->
	<xs:element name="key">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="value" maxOccurs="unbounded"/>			
			</xs:sequence>
			<xs:attribute name="v" type="xs:string" use="required" />
		</xs:complexType>
	</xs:element>
				
	<!--  Element: value -->
	<xs:element name="value">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="description" minOccurs="0" />
				<xs:element ref="uri" minOccurs="0" />
				<xs:element ref="useful" minOccurs="0" maxOccurs="unbounded" />
			</xs:sequence>
			<xs:attribute name="isArea" type="xs:boolean" default="false" />
			<xs:attribute name="isNode" type="xs:boolean" default="false" />
			<xs:attribute name="isWay" type="xs:boolean" default="false" />
			<xs:attribute name="type" type="xs:string" use="required" />
			<xs:attribute name="v" type="xs:string" use="required" />
		</xs:complexType>
	</xs:element>
	
	<!-- Element: description -->
	<xs:element name="description" type="xs:string" />
	
	<!-- Element: uri -->
	<xs:element name="uri" type="xs:anyURI" />
	
	<!-- Element: useful -->
	<xs:element name="useful">
		<xs:complexType>
			<xs:attribute name="v" type="xs:string" use="required" />
		</xs:complexType>
	</xs:element>
	
	<!-- Root element -->
	<xs:element name="map_features">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="key" maxOccurs="unbounded" />
			</xs:sequence>
			<xs:attribute name="lang" type="xs:string" default="en" />
		</xs:complexType>
	</xs:element>
</xs:schema>
}}}

= Code =

No Java, because... well, just because.

{{{
module OsmMapFeatures
    require 'net/http'
    require 'rubygems'
    require 'builder'

    @tags = Hash.new
    @descriptions = Hash.new
    @flags = Hash.new
    @parse_usefuls = true

    @number_regexps = [
        /^Nombre$/i,
        /^Num$/i,
        /^Number$/i,
        /^Zahl$/i,
        /^-?[0-9]+$/,
        /^[0-9]+-[0-9]+$/,
    ]

    @anytext_regexps = [
        /\s+/,
    ]

    @blacklists = Hash.new
    @blacklists[:keys] = [
        "Hilfe für Kartennutzer"
    ]

    def parse_keys_and_values(lang = '')
        f = get_page("http://wiki.openstreetmap.org/wiki/#{lang}Map_Features")
        tags = f.scan(/<tr>\s+<td>(.*?)<\/td><td>(.*?)<\/td><td>(.*?)<\/td><td>(.*?)<\/td>/m)

        tags.each do |tag|
            key = tag[0].gsub(/<.*?>/, '').strip
            value = tag[1].gsub(/<.*?>/, '').strip
            value_details = tag[1].strip
            flags = tag[2].strip
            description = tag[3].gsub(/<.*?>/, '').strip

            @tags[key] ||= Hash.new
            @flags[key] ||= Hash.new
            @descriptions[key] ||= Hash.new

            @tags[key][value] = value_details
            @flags[key][value] = Hash.new
            @descriptions[key][value] = description

            %w{ Node Way Area }.each do |item|
                @flags[key][value]["is#{item}"] = (flags.match(/title="#{item}"/) ? 'true' : 'false')
            end
        end
    end

    def p_xml(lang = '')
        xml = Builder::XmlMarkup.new(:target => STDOUT, :indent => 2)
        xml.map_features(:lang  => lang.downcase.sub(':', ''),
                         :xmlns => "http://code.google.com/p/swp-dv-ws2010-osm-1/OSM_Tags") do
            @tags.keys.sort.each do |key|
                next if is_blacklisted?(key, @blacklists[:keys]);

                xml.key(:v => key.gsub(/%/, '').gsub(/&.+?/, '').strip) do
                    @tags[key].keys.sort.each do |value|
                        empty_value_has_been_printed_before = false; 

                        (value == '' ? 'User defined' : value).split(/[\/,]/).sort.each do |v|
                            next if v.match(/\.\.\./)
                            v = v.gsub(/[%°]/, '').gsub(/&.+?/, '').strip
                            
                            value_type = (is_number?(v) ? 'number' : 'text')

                            if (value_type == 'number')
                            	v = '' 
                            else
                            	v = (is_any_text?(v) ? '' : v)
                            end

                            if (v == '')
                                next if empty_value_has_been_printed_before
                                empty_value_has_been_printed_before = true
                            end

                            xml.value(@flags[key][value].merge({:type => value_type, :v => v})) do
                                xml.description(@descriptions[key][value].gsub(/\s+/, ' ').gsub('&', '&amp;'))

                                if (not @tags[key][value].match(/class="new"/))
                                    href = @tags[key][value].scan(/href="(.*?)"/).to_s.strip
                                    xml.uri("http://wiki.openstreetmap.org#{(lang == '' ? href : href.gsub(/Tag:/, "#{lang}Tag:"))}") if href != ''

                                    if (@parse_usefuls and href != '')
                                        useful_tags = get_useful_tags("http://wiki.openstreetmap.org#{href.to_s.strip}")
                                        
                                        useful_tags.sort.each do |useful_tag|
                                            xml.useful(:v => useful_tag) unless (useful_tag == '' or useful_tag.match(/ /))
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    def is_blacklisted?(s, blacklist)
    	blacklist.each { |blacklisted_item| return true if s.match(blacklisted_item) }
    	false
    end
    
    def is_any_text?(s, anytext_regexps = @anytext_regexps)
		anytext_regexps.each { |regexp| return true if s.match(regexp) }        
        false    	
    end
    
    def is_number?(s, number_regexps = @number_regexps)    	
    	number_regexps.each { |regexp| return true if s.match(regexp) }        
        false
    end
    
    def get_useful_tags(uri)
    	useful_page = get_page(uri)
    	useful_tags = useful_page.scan(/<dl><dt>Useful combination(.*?)<dl><dt>/m).to_s.scan(/<li>(.*?)<\/li>/m)
    	
    	useful_tags.map { |x| x.to_s.gsub(/<.*?>/m, '').gsub(/=.*/, '').gsub(/Key:/i, '').strip }
    end
    
    def get_page(uri)
        Net::HTTP.get(URI.parse(uri))
    end
end
}}}

= Usage =

{{{
include OsmMapFeatures

OsmMapFeatures.parse_keys_and_values 'DE'
OsmMapFeatures.p_xml 'DE'
}}}